df  <- mtcars

cor.test(x = df$mpg, y = df$hp)
fit  <- cor.test(x = df$mpg, y = df$hp)

cor.test(~ mpg + hp, df)

str(fit)

fit$p.value

plot(x = df$mpg, y = df$hp)

ggplot(df, aes(x = mpg, y = hp, col = factor(cyl)))+
  geom_point(size = 5)+
  facet_grid(. ~ am)


###########################################
library(psych)

df  <- mtcars
df_numeric  <- df[, c(1,3:7)]

pairs(df_numeric)

cor(df_numeric)

fit  <- corr.test(df_numeric)
fit$r
fit$p
fit$adjust


# Напишите функцию corr.calc, которая на вход получает data.frame с двумя количественными 
# переменными, рассчитывает коэффициент корреляции Пирсона и возвращает вектор из двух 
# значений: коэффициент корреляции и p - уровень значимости.
# 
# Пример работы функции:
# > corr.calc( mtcars[, c(1,5)] )  # на вход подаем данные mtcars только с переменными 
# mpg и drat
# [1] 0.6811719078 0.0000177624
# 
# > corr.calc( iris[,1:2] ) # на вход подаем данные iris только с переменными 
# Sepal.Length и Sepal.Width
# [1] -0.1175698 0.1518983
# 
# 
# При написании функции обратите внимание, что названия переменных входящего dataframe 
# могут быть произвольными. Пишите функцию с учетом, что она должна работать на любом  
# dataframe с двумя количественными переменными как в примере выше.
# 
# Не забудьте подгрузить библиотеку library(psych), если хотите использовать ее при 
# решении этой задачи.

library(psych)
corr.calc <- function(df){
  res <- corr.test(df[1], df[2])
  return(c(res$r, res$p))
}
corr.calc( iris[,1:2] )



# Напишите функцию filtered.cor которая на вход получает data.frame с  произвольным 
# количеством переменных (как количественными, так и любых других типов), рассчитывает 
# коэффициенты корреляции Пирсона между всеми парами количественных переменных и
# возвращает наибольшее по модулю значение коэффициента корреляции. (То есть функция может
# вернуть -0.9, если это наибольшая по модулю  корреляция).
# 
# Гарантируется наличие в data.frame хотя бы двух количественных переменных.
# 
# Обратите внимание: при проверке вашей функции на вход будут подаваться данные с 
# различными именами колонок. Ваша функция должна корректно работать независимо от имен
# переменных. Перед тем, как сдавать решение, убедитесь, что ваша функция работает 
# корректно на разных данных, с разными именами колонок. 
# 
# Если вы хотите использовать функцию corr.test не забудьте загрузить библиотекy psych.
# 
# Данные для тренировки:
# https://stepik.org/media/attachments/lesson/11504/step6.csv
# 
# step6 <-  read.table("step6.csv",  header=TRUE, sep=',' )
# > filtered.cor(step6)
# [1] 0.235997
# 
# > filtered.cor(my_df) #вымышленные данные, где максимальная по модулю корреляция 
# отрицательна
# [1] -0.9
# 
# > filtered.cor(iris)
# [1] 0.9628654  
# 
# > iris$Petal.Length <- -iris$Petal.Length # сделаем отрицательной максимальную по модулю
# корреляцию
# > filtered.cor(iris)
# [1] - 0.9628654
# 
# 1. мы подробнее поговорим о функциях семейства apply в следующем курсе - Advanced R, но вы
#    можете изучить справку о apply и sapply. Для решения данной задачи, эти функции могут
#    пригодиться.
# 2. обратите внимание на функцию which.max()
# 3. обратите внимание на конструкцию diag(matrix) <- n
# 4. если вы получаете ошибку, 'x' must be a numeric vector, значит в данных остались не
#    только количественные переменные.

df <- read.csv('data/step6.csv')

library(psych)
filtered.cor <- function(df){
  df <- df[sapply(df,is.numeric)]
  res <- corr.test(df)
  diag(res$r) <- 0
  idx <- which.max(abs(res$r))
  return(res$r[idx])
}


# Напишите функцию smart_cor, которая получает на вход dataframe с двумя количественными 
# переменными. Проверьте с помощью теста Шапиро-Уилка, что данные в обеих переменных 
# принадлежат нормальному распределению.
# 
# Если хотя бы в одном векторе распределение переменной отличается от нормального 
# (p - value меньше 0.05), то функция должна возвращать коэффициент корреляции Спирмена. 
# (Числовой вектор из одного элемента).
# 
# Если в обоих векторах распределение переменных от нормального значимо не отличается, 
# то функция должна возвращать коэффициент корреляции Пирсона.
# 
# > test_data  <- read.csv("https://stepik.org/media/attachments/course/129/test_data.csv﻿")
# > smart_cor(test_data)
# [1] -0.1031003

library(psych)
smart_cor <- function(df){
  if (0.05 > shapiro.test(df[[1]])$p.value | 0.05 > shapiro.test(df[[2]])$p.value) {
    res <- corr.test(df, method = 'spearman')
  } else {
    res <- corr.test(df)
  }
  return(res$ci$r)
}


