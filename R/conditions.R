# control statements

mydata <- read.csv('evals.csv')



# if

a <- 

if (a > 0){
  print('positive')
} else {
  print('not positive')
}


if (a > 0){
  print('positive')
} else print('not positive')


if (a > 0){
  print('positive')
} else if (a < 0) {
  print('negative')
} else print('zero')



# ifelse

a <- 10


ifelse(a > 0, 'positive', 'not positive')

a <- c(1, -1)


# for 

for (i in 1:100){
  print(i)
}


for (i in 1:nrow(mydata)){
  print(mydata$score[i])
}



# for + if
for (i in 1:nrow(mydata)){
  if (mydata$gender[i] == 'male'){
    print(mydata$score[i]) 
  }
}



# for + if  VS  ifelse

mydata$quality <- rep(NA, nrow(mydata))

for (i in 1:nrow(mydata)){
  if (mydata$score[i] > 4){
    mydata$quality[i] <- 'good'
  } else mydata$quality[i] <- 'bad'
}






mydata$quality2 <- ifelse(mydata$score > 4, 'good', 'bad')







# while

i <- 1

while(i < 51){
  print(mydata$score[i])
  i <- i+1
}


# Создайте новую числовую переменную  new_var в данных mtcars, которая содержит 
# единицы в строчках, если в машине не меньше четырёх карбюраторов 
# (переменная "carb") или больше шести цилиндров (переменная "cyl"). 
# В строчках, в которых условие не выполняется, должны стоять нули.

mtcars$new_var <- ifelse(mtcars$carb >=4 | mtcars$cyl > 6, 1, 0)


# В уже существующей переменной my_vector сохранен вектор из 50 чисел.
# 
# Решите задачу используя конструкцию:

# if () {
#   
# } else {
#   
# } 

# Если среднее значение вектора my_vector больше 20, в переменную result 
# сохраните "My mean is great",  если среднее значение my_vector меньше или 
# равно 20 то в переменную result сохраните  строку "My mean is not so great".

if (mean(my_vector) > 20) {
  result = "My mean is great"
} else {
  result = "My mean is not so great"
}


# В этой задаче от вас потребуется узнать некоторую информацию о типах данных 
# в R самостоятельно! Встроенные в R данные AirPassengers - это новый для нас 
# формат данных типа Time-Series. Изучите структуру этих данных, прежде чем 
# начать решение задачи! Например напишите команды:
#   
# > ?AirPassengers # справка о данных
# > str(AirPassengers) # структура данных
# 
# В встроенных в R данных AirPassengers хранится 144 значения 
# (количество пассажиров в месяц) с 1949 по 1960 год. Данные Time-Series очень 
# похожи на вектор по своей структуре, например мы можем обратиться к любому из 
# 144 элементов используя уже знакомую нам индексацию AirPassengers[1] или 
# AirPassengers[56].
# 
# Можно вообще перевести исходные данные в вектор при помощи команды 
# as.vector(AirPassengers) и продолжить с ними работу как с вектором.
# 
# И так ваша задача создать переменную good_months и сохранить в нее число 
# пассажиров только в тех месяцах, в которых это число больше, чем показатель 
# в предыдущем месяце.  
# 
# Важный момент! В R оператор : для создания последовательности имеет приоритет 
# над арифметическими действиями. Таким образом, если у вас есть переменная i, 
# равная 10, и вы хотите создать вектор от 1 до i - 1, воспользуйтесь скобками, 
# чтобы указать последовательность действий.
# 
# > i <- 10
# > 1 : i - 1 # так мы создадим последовательность от 1 до 10, а потом вычтем 
#             единицу из каждого элемента
# [1] 0 1 2 3 4 5 6 7 8 9
# 
# > 1 : (i - 1) # а вот так мы создадим последовательность от 1 до i - 1, 
#               то есть от 1 до 9. 
# [1] 1 2 3 4 5 6 7 8 9
good_months <- c()
prep <- NA

for (variable in AirPassengers) {
  if ( !is.na(prep) & variable > prep) {
    good_months <- c(good_months, variable)  
    prep <- variable
  } else {
    prep <- variable
  }
}

# Пример правильного решения без цикла:
good_months <- AirPassengers[-1][AirPassengers[-1] > AirPassengers[-144]]



# Задачка для супер героев, повышенной сложности!
#   
# Для встроенных в R данных AirPassengers рассчитайте скользящее среднее с 
# интервалом сглаживания равным 10. Напечатайте получившийся результат 
# (первым значением в выводе должно быть среднее для элементов 1:10, во 
# втором значении - среднее для элементов 2:11 и т.д., в последнем  - 
# среднее для элементов 135 :144)
# 
# Все полученные значения средних сохраните в переменную moving_average.
# 
# Пример расчета для вектора из 11 элементов:

if (!require("png")) install.packages("png")

library("png")

pp <- readPNG("img.png")
plot.new() 
rasterImage(pp,0,0,1,1)

# Соответственно, для наших данных из 144 наблюдений должно получиться 135 
# средних (первые и последние 4 средних):
#   
# 129.8 129.0 129.0 127.3 ... 483.6 489.2 486.5 490.6
# 
# Если вам потребуется создать вектор moving_average заранее, то есть несколько 
# способов сделать это:
#   1. самый простой, но не очень правильный вариант - создать пустой вектор
#     
#     moving_average <- c()
# 
#   2. можно сразу создать вектор определенной длины и определенного типа:
# 
#     moving_average <- numeric(135)
#   
# Такой вариант является более предпочтительным. Почему? Узнаем во второй части 
# курса!)
# 
# А для тем, кто уже выбрал путь воина и не хочет использовать цикл - советую 
# познакомиться с функцией cumsum. Подсказка: если у нас есть два вектора 
# одинаковой длинны, то если из одного вектора вычесть второй вектор, мы найдем 
# разность для первых элементов векторов, затем для вторых и т.д.
# 
# 
# > x <- c(2, 4, 7)
# 
# > y <- c(2, 3, 5)
# 
# > x - y
# 
# [1] 0 1 2
 
# replicate(144, 1)
moving_average <- numeric(135)
first_value <- sum((AirPassengers)[1:10]) / 10
other_values <- (cumsum(AirPassengers)[11:144] - cumsum(AirPassengers[1:134])) / 10
moving_average <- c(first_value, other_values)

